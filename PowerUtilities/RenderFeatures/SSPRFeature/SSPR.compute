#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
// #include "../../../../PowerShaderLib/Lib/NoiseLib.hlsl"
/**
supporet apis:
	dx, vulkan,( RWTexture2D)
	glcore,es3.1, 3.0(2 pass csmain)
	metal(ios,mac)( RWBuffer)
*/
// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSClear
#pragma kernel CSMain
#pragma kernel CSHashClear
#pragma kernel CSHash
#pragma kernel CSResolve
// #pragma target 4.5

/**
	huawei p, es3,need 8
*/
#if defined(SHADER_API_GLES3)
	#define THREAD_X 8
	#define THREAD_Y 8
#else
	#define THREAD_X 32
	#define THREAD_Y 32
#endif
#define THREAD_Z 1

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> _ReflectionTexture;
RWTexture2D<float> _ReflectionHeightBuffer;

SamplerState sampler_point_clamp,sampler_linear_clamp;
TEXTURE2D(_CameraOpaqueTexture);
float4 _CameraOpaqueTexture_TexelSize; 

TEXTURE2D_FLOAT(_CameraDepthTexture);
float4 _CameraTexture_TexelSize; // width,height,1/width,1/height

float4 _Plane; // xyz:plane direction, w : - dot(plane location, plane direction)
float4 _TexSize; //x:width,height,1/width,1/height
float4 _Stretch; //x:camera forward.z, stretch threshold,stretch intensity,isApplyStretch
float2 _FadingRange; //[min,max]
int _FixedHole;
float4x4 _VP,_InvVP;

// #define TEST_BUFFER // for debug RWBuffer

#if defined(SHADER_API_METAL) || defined(SHADER_API_VULKAN)
	RWBuffer<uint> _HashResult;
	uint GetIndex(uint2 id){
		return id.y * _TexSize.x + id.x;
	}
	#define INDEX(id) GetIndex(id)
#else
	RWTexture2D<uint> _HashResult;
	#define INDEX(id) id
#endif


void ApplyStretch(inout float2 reflectUV,float distance){
	// stretch 
	float heightStretch = distance;
	float angleStretch = saturate(_Stretch.x);
	float screensStretch = saturate(abs(reflectUV.x * 2 -1) - _Stretch.y);
	reflectUV.x *= 1 + heightStretch * angleStretch * screensStretch * _Stretch.z;
}

float LoadDepth(float2 uv){
	uint2 pos = uint2(uv * _CameraTexture_TexelSize.xy);
	float depth = LOAD_TEXTURE2D(_CameraDepthTexture,pos).x;

	#if ! defined(UNITY_REVERSED_Z)
		depth = depth * 2 - 1;
	#endif

	return depth;
}

/*
	Fading out by distance,save to _ReflectionTexture.w
*/
float GetDistanceFading(float distance){
	float rate = (distance - _FadingRange.x)/(_FadingRange.y - _FadingRange.x);
	return saturate(1-rate);
}

/**
	Get distance from plane to world space position
*/
float CalcDistance(float2 uv){
	float depth = LoadDepth(uv);
	float3 wpos = ComputeWorldSpacePosition(uv,depth,_InvVP);

	float distance = dot(wpos,_Plane.xyz) + _Plane.w;
	return distance;
}

half4 SampleColorTexture(float2 uv){
	half4 c = SAMPLE_TEXTURE2D_LOD(_CameraOpaqueTexture,sampler_point_clamp,uv,0);
	return c;
}

void CalcDistanceAndReflectUV(float2 uv,out float distance,out float2 reflectUV){
	float depth = LoadDepth(uv);
	float3 wpos = ComputeWorldSpacePosition(uv,depth,_InvVP);

	distance = dot(wpos,_Plane.xyz) + _Plane.w;

	float3 reflectPosWS = wpos - _Plane.xyz * distance * 2;
	float4 reflectPosCS = mul(_VP,float4(reflectPosWS,1));  //TransformWorldToHClip(reflectPosWS);
	reflectUV = reflectPosCS.xy/reflectPosCS.w * 0.5 + 0.5;

}

[numthreads(THREAD_X,THREAD_Y,THREAD_Z)]
void CSClear(uint3 id:SV_DispatchThreadID){
	if(any(id.xy > uint2(_TexSize.xy)))
		return;
    _ReflectionTexture[id.xy] = 0;
    _ReflectionHeightBuffer[id.xy] = FLT_MAX;
}

[numthreads(THREAD_X,THREAD_Y,THREAD_Z)]
void CSMain(uint3 id:SV_DispatchThreadID){
	if(any(id.xy > uint2(_TexSize.xy)))
		return;
	
	float2 uv = id.xy * _TexSize.zw;
	float depth = LoadDepth(uv);

	float3 wpos = ComputeWorldSpacePosition(uv,depth,UNITY_MATRIX_I_VP);

	float distance = dot(wpos,_Plane.xyz) + _Plane.w;
	if(distance < 0.0001)
		return;
	
	float3 reflectPosWS = wpos - _Plane.xyz * distance * 2;
	float4 reflectPosCS = TransformWorldToHClip(reflectPosWS);
	float2 reflectUV = reflectPosCS.xy/reflectPosCS.w * 0.5 + 0.5;
	if(all(reflectUV >= 0) && all(reflectUV <= 1))
	{
		if(_Stretch.w)
			ApplyStretch(reflectUV,distance);

		#if UNITY_UV_STARTS_AT_TOP
			reflectUV.y = 1 - reflectUV.y;
		#endif
		
		uint2 location = uint2(reflectUV * _TexSize.xy);
		
        if(wpos.y < _ReflectionHeightBuffer[location])
        {
            _ReflectionHeightBuffer[location] = wpos.y;
			half4 reflectCol =  SampleColorTexture(uv);
			half distanceFading = GetDistanceFading(distance);
			reflectCol.xyz *= distanceFading;

			half4 lastReflectCol = _ReflectionTexture[location];
			// location += N12(_Time.x) *2;
			_ReflectionTexture[location] = reflectCol;
			// _ReflectionTexture[location+uint2(1,0)] = reflectCol;
			// _ReflectionTexture[location] = lerp(lastReflectCol,reflectCol,0.8);
        }

	}
}


[numthreads(THREAD_X,THREAD_Y,THREAD_Z)]
void CSHashClear(uint3 id:SV_DispatchThreadID){
	if(any(id.xy > uint2(_TexSize.xy)))
		return;
    _ReflectionTexture[id.xy] = 0;
	_HashResult[INDEX(id.xy)] = 0xffffffff;
}
/**
	Get reflection id(texel position) ,
	y in high 16 bits,y in low 16 bits
*/
[numthreads(THREAD_X,THREAD_Y,THREAD_Z)]
void CSHash(uint3 id:SV_DispatchThreadID){
	if(any(id.xy > uint2(_TexSize.xy)))
		return;

	float2 uv = id.xy * _TexSize.zw;
	float distance = 0;
	float2 reflectUV = 0;
	
	CalcDistanceAndReflectUV(uv,distance/**/,reflectUV/**/);

	bool isTooNear = distance < 0.0001;

	bool isReflectUVValid = all(reflectUV >= 0) && all(reflectUV <= 1);
	bool isValid = !isTooNear && isReflectUVValid;
	// if(!isValid)
	// 	return;

	if(_Stretch.w)
		ApplyStretch(reflectUV/**/,distance);
	
	#if UNITY_UV_STARTS_AT_TOP
		reflectUV.y = 1 - reflectUV.y;
	#endif

	uint2 location = uint2(reflectUV * _TexSize.xy);
	
	uint hash = (id.y<<16)|(id.x & 0xffff);
	hash = isValid? hash : 0xffffffff;

	uint _;
	InterlockedMin(_HashResult[INDEX(location)],hash,_);
}
/**
	Get a valid sample from 5 samples,
	0xffffffff means invalid
*/
uint GetHash4Corners(uint2 id,uint hash){
	const uint2 offsets[4] = {-1,-1, -1,1, 1,1, 1,-1};
	
	#if defined(SHADER_API_METAL)
	if(any(id == 0) || any(id >= _TexSize.xy))
		return hash;
	#endif

	UNITY_UNROLL
	for(int i=0;i<4;i++)
	{
		hash = min(_HashResult[INDEX(id.xy + offsets[i])],hash);
	}
	return hash;

	// if(hash >= 0xffffffff)
	// 	hash = _HashResult[id.xy+uint2(-1,-1)];
	// if(hash >= 0xffffffff)
	// 	hash = _HashResult[id.xy+uint2(-1,1)];
	// if(hash >= 0xffffffff)
	// 	hash = _HashResult[id.xy+uint2(1,-1)];
	// if(hash >= 0xffffffff)
	// 	hash = _HashResult[id.xy+uint2(1,1)];
	// return hash;
}

float4 SampleColorTexture(uint hash){
	float4 c = 0;
	float2 pos = float2(hash&0xffff,hash>>16);
	float2 uv = pos*_TexSize.zw;
	uv += 0.5 * _TexSize.zw; // offset 0.5 pixel, make blur little

	c = SampleColorTexture(uv);
	
	float distance = CalcDistance(uv);
	c.w = GetDistanceFading(distance); // fading out by distance

	half isValid = (hash < 0xffffffff);
	return c * isValid;
}

[numthreads(THREAD_X,THREAD_Y,THREAD_Z)]
void CSResolve(uint3 id:SV_DispatchThreadID){
	if(any(id.xy > uint2(_TexSize.xy)))
		return;

	uint hash = (_HashResult[INDEX(id.xy)]);
	if(_FixedHole)
		hash = GetHash4Corners(id.xy,hash);

	half4 col = SampleColorTexture(hash);
	_ReflectionTexture[id.xy] = col;
}